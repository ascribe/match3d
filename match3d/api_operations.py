from three_d_match import ThreeDSearch
from shutil import copy
from elasticsearch.helpers import bulk, scan
from os.path import join, abspath, expanduser
from os import listdir, remove, environ
from image_match.signature_database_base import make_record
import tempfile
from shutil import rmtree
import requests


class APIOperations(ThreeDSearch):
    def __init__(self, es_nodes=environ.get('ES_HOSTS', 'localhost'),
                 index_name='match3d',
                 cutoff=0.5):

        self.index_name = index_name

        # the parent class provides the methods for rendering in blender
        super(APIOperations, self).__init__(es_nodes=es_nodes,
                                            index_name=index_name,
                                            cutoff=cutoff)

    def add(self, stl_id, stl_url=None, stl_file=None, doc_type='image'):
        """
        Add an STL design to an elasticsearch database for matching

        :param stl_id: an identifier for the STL file. must be unique.
        :param stl_url: the PUBLIC url pointing to the STL file (optional)
        :param stl_file: path to an STL file. ignored if stl_url is provided, but one must be given (optional)
        :param doc_type: specify the doc_type for elasticsearch renders. You shouldn't need to change this
        """

        # set up temporary directories
        input_directory = tempfile.mkdtemp()
        output_directory = tempfile.mkdtemp()
        temporary_stl = tempfile.mkstemp(suffix='.stl')[-1]

        # TODO: many of these functions should be parallelized
        try:
            # if a url is supplied, attempt to download the STL
            if stl_url:
                r = requests.get(stl_url)
                with open(temporary_stl, 'wb') as f:
                    f.write(r.content)
                stl_file = temporary_stl

            # copy the supplied stl file or requested data to a temp dir
            copy(stl_file, input_directory)

            # TODO remove, as it seems to be unused
            path = join(input_directory, stl_file)

            # set up and run the rendering process. fork and wait for completion
            blender_args = ['blender',
                            '-b', '-P', 'image_match_generator.py', '--',
                            '-d', abspath(expanduser(input_directory)),
                            '-o', output_directory,
                            ]

            self.generate_images(input_directory, blender_args=blender_args)

            to_insert = []

            # add image signatures to elasticsearch
            for image_path in listdir(output_directory):
                # ignore the .csv report generated by the renderer
                if image_path.split('.')[-1] != 'csv':
                    rec = make_record(join(output_directory, image_path),
                                      self.ses.gis,
                                      self.ses.k,
                                      self.ses.N)

                    rec['stl_id'] = stl_id

                    to_insert.append({
                        '_index': self.ses.index,
                        '_type': doc_type,
                        '_source': rec
                    })

            _, errs = bulk(self.es, to_insert)

        finally:
            # clean up temporary locations
            rmtree(input_directory)
            rmtree(output_directory)
            remove(temporary_stl)

    def search(self, stl_url=None, stl_file=None, return_raw=False, ranking='single'):
        """
        Search by STL file for similar designs
        :param stl_url: the PUBLIC url pointing to the STL file (optional)
        :param stl_file: path to an STL file. ignored if stl_id is provided, but you must provide one of the two (optional)
        :param return_raw: if True, return raw scores per image instead of a composite score (default False)
        :param ranking: ranking system to use. No need to changes this
        :return: list of matches, or None
        """

        # add index names if necessary (this is a hack, should really be in image_search)
        if 'index_names' not in self.ses.__dict__:
            example_res = self.es.search(index=self.index_name, size=1)
            if example_res['hits']['total'] > 0:
                self.ses.index_names = [field for field in example_res['hits']['hits'][0]['_source'].keys() if field.find('simple') > -1]

        try:
            input_directory = tempfile.mkdtemp()
            temporary_stl = tempfile.mkstemp(suffix='.stl')[-1]

            # if a url is supplied, attempt to download the STL
            if stl_url:
                r = requests.get(stl_url)
                with open(temporary_stl, 'wb') as f:
                    f.write(r.content)
                stl_file = temporary_stl

            copy(stl_file, input_directory)
            images_directory = self.generate_images(input_directory)
            res = self.search_images(images_directory)
        finally:
            rmtree(input_directory)
            rmtree(images_directory)
        if return_raw:
            return res
        elif ranking == 'single':
            if stl_url:
                return {stl_url: self._best_single_image(res)}
            else:
                return {stl_file: self._best_single_image(res)}

    def list_designs(self):
        """
        Return a list designs in corpus

        :return: a list of all design ids
        """
        result = {}
        s = scan(self.es, index=self.index_name)
        for r in s:
            result.update({r['_source']['stl_id']: True})

        return result.keys()

    def _best_single_image(self, results, n_per_view=5):
        scores = {}
        for result in results:
            for i in range(n_per_view):
                if result:
                    best = min(result, key=lambda x: x['dist'])
                    k = self.es.get(id=best['id'], index=self.ses.index, doc_type='image',
                                         fields=['stl_id'])['fields']['stl_id'][0]
                    if k not in scores:
                        scores[k] = best['dist']
                    elif best['dist'] < scores[k]:
                        scores[k] = best['dist']
                    result.remove(best)
        return scores
